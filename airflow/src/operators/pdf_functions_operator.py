"""PDF functions operator - split PDF files."""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Callable, List, Optional, Sequence

from airflow.exceptions import AirflowException
from airflow.models import BaseOperator
from airflow.utils.context import Context
from pypdf import PdfReader, PdfWriter


from services.saga import (
    build_saga_event,
    get_saga_from_context,
    log_saga,
    send_saga_event_to_api,
)

from .plugins import rotate_pdf_with_ocr

logger = logging.getLogger(__name__)


class PdfFunctionsOperator(BaseOperator):
    """
    Custom Airflow operator that splits PDF files into single-page files.

    Args:
        folder_path: Directory containing PDF files to process.
        output_dir: Directory where the processed files will be stored.
        functions: Ordered list of functions to execute. Supported: ["split", "rotate"].
        overwrite: Whether to overwrite existing files when writing outputs.
        include_single_page: Whether to include single-page PDFs when splitting.
        task_id: Airflow task id (required by BaseOperator but exposed for completeness).
    """

    SUPPORTED_FUNCTIONS: dict[str, str] = {
        "split": "_split_pdfs",
        "rotate": "_rotate_pdfs",
    }

    def __init__(
        self,
        folder_path: str,
        output_dir: Optional[str] = None,
        functions: Optional[List[str]] = None,
        overwrite: bool = True,
        include_single_page: bool = False,
        task_id: Optional[str] = None,
        **kwargs,
    ) -> None:
        super().__init__(task_id=task_id, **kwargs)
        self.folder_path = Path(folder_path)
        self.output_dir = Path(output_dir) if output_dir else self.folder_path
        self.overwrite = overwrite
        self.include_single_page = include_single_page
        self.functions = functions or ["split"]

    def execute(self, context: Context) -> List[str]:
        """
        Execute the configured PDF functions pipeline.

        Returns:
            List of file paths generated by the final function in the pipeline.
        """
        logger.info("Starting PdfFunctionsOperator for folder: %s", self.folder_path)

        saga = get_saga_from_context(context)

        if not self.folder_path.exists() or not self.folder_path.is_dir():
            raise AirflowException(
                f"Folder path {self.folder_path} does not exist or is not a directory."
            )

        pdf_files = sorted(self.folder_path.glob("*.pdf"))
        if not pdf_files:
            logger.warning("No PDF files found at %s", self.folder_path)
            if saga:
                self._update_saga_with_event(saga, context, success=True, files_count=0)
            return []

        current_files: List[Path] = list(map(Path, pdf_files))
        self.output_dir.mkdir(parents=True, exist_ok=True)

        current_files = self._run_pipeline(current_files)

        generated_files = [str(path) for path in current_files]

        logger.info(
            "PdfFunctionsOperator executed %d function(s) and produced %d files.",
            len(self.functions),
            len(generated_files),
        )

        if saga:
            self._update_saga_with_event(
                saga, context, success=True, files_count=len(generated_files)
            )

        return generated_files

    def _run_pipeline(self, files: List[Path]) -> List[Path]:
        """Apply the configured pipeline and return resulting files."""
        current_files = files
        for function_name in self.functions:
            handler_name = self.SUPPORTED_FUNCTIONS.get(function_name)
            if handler_name is None:
                raise AirflowException(
                    f"Unsupported PDF function '{function_name}'. "
                    f"Supported functions: {list(self.SUPPORTED_FUNCTIONS.keys())}"
                )
            handler: Callable[[Sequence[Path]], List[Path]] = getattr(self, handler_name)
            current_files = handler(current_files)
            if not current_files:
                logger.warning("Function '%s' produced no output files", function_name)
                break
        return current_files
    
    def _update_saga_with_event(
        self,
        saga: dict,
        context: Context,
        success: bool,
        files_count: int,
    ) -> None:
        """Update SAGA with PDF functions event and push to XCom."""
        if not saga or not saga.get("saga_id"):
            logger.warning("SAGA missing saga_id, skipping event update")
            return
        
        # Ensure events list exists
        if "events" not in saga:
            saga["events"] = []
        
        # Build event for PDF-processing operation
        event = build_saga_event(
            event_type="TaskCompleted" if success else "TaskFailed",
            event_data={
                "step": "pdf_functions",
                "status": "SUCCESS" if success else "FAILED",
                "files_generated": files_count,
                "input_folder": str(self.folder_path),
                "output_folder": str(self.output_dir)
            },
            context=context,
            task_id=self.task_id
        )
        saga["events"].append(event)
        
        # Send event to rpa-api for persistence
        send_saga_event_to_api(saga, event, rpa_api_conn_id="rpa_api")
        
        # Update events_count
        saga["events_count"] = len(saga["events"])
        
        # Update current_state
        if success:
            saga["current_state"] = "RUNNING"  # Still in progress, not completed yet
        
        # Push updated SAGA back to XCom
        task_instance = context.get('task_instance')
        if task_instance:
            task_instance.xcom_push(key="saga", value=saga)
            task_instance.xcom_push(key="rpa_payload", value=saga)  # Backward compatibility
        
        # Log SAGA
        log_saga(saga, task_id=self.task_id)

    def _split_pdfs(self, files: Sequence[Path]) -> List[Path]:
        """Split PDFs into single-page files."""
        if not files:
            return []

        output_paths: List[Path] = []
        for pdf_path in files:
            logger.debug("Splitting PDF file: %s", pdf_path)
            reader = PdfReader(str(pdf_path))
            num_pages = len(reader.pages)

            if num_pages <= 1:
                if self.include_single_page:
                    target_path = self.output_dir / f"{pdf_path.stem}_1.pdf"
                    self._write_pages(reader.pages[0:1], target_path)
                    output_paths.append(target_path)
                continue

            for index, page in enumerate(reader.pages, start=1):
                target_path = self.output_dir / f"{pdf_path.stem}_{index}.pdf"
                self._write_pages([page], target_path)
                output_paths.append(target_path)

            logger.info(
                "Split %s into %d files stored in %s",
                pdf_path.name,
                len(reader.pages),
                self.output_dir,
            )

        return output_paths


    def _write_pages(self, pages: Sequence, target_path: Path) -> None:
        """Write given pages to the target PDF path."""
        if target_path.exists() and not self.overwrite:
            raise AirflowException(
                f"Target file {target_path} exists. Set overwrite=True to replace."
            )

        writer = PdfWriter()
        for page in pages:
            writer.add_page(page)

        with target_path.open("wb") as target_file:
            writer.write(target_file)


    def _rotate_pdfs(self, files: Sequence[Path]) -> List[Path]:
        """Rotate PDFs using the OCR-based plugin (documents saved to output_dir)."""
        if not files:
            return []

        rotated_paths: List[Path] = []
        self.output_dir.mkdir(parents=True, exist_ok=True)

        for pdf_path in files:
            target_path = self.output_dir / pdf_path.name
            if target_path == pdf_path and not self.overwrite:
                raise AirflowException(
                    f"Target file {target_path} exists. Set overwrite=True to replace."
                )

            logger.info("Rotating PDF %s -> %s", pdf_path, target_path)
            rotated = rotate_pdf_with_ocr(pdf_path, target_path)
            rotated_paths.append(Path(rotated))

        return rotated_paths



